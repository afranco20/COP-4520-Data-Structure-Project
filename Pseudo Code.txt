Pseudo Code

-------------- Data Types ------------------

******* Hash-Cache Trie ********

class SNode
	val hash: Int
	val key: KeyType
	val value: ValueType
	val txn: Any

type ANode = Array<Any>

val NoTxn

val FSNode

val FVNode

class FNode
	val frozen: Any

class ENode
	val parent: ANode
	val parentpos: Int
	val narrow: ANode
	val hash: Int
	val level: Int
	val wide: ANode

class CacheTrie
	val root = new ANode(16)

******* Auxilary Cache ********

type Cache = Array<Any>

class CacheNode
	val parent: Array<Any>
	val misses: Array<Int>

******* MODIFIED CACHETRIE CLASS W/ CACHE OBJECT ********	

class CacheTrie
	val root = new ANode(16)
	var cacheHead: Cache = null
	

-------------- Functions ------------------	

******* Cache Helper *********

def createCache(level: Int, parent: Cache): Cache = 
	val cache = new Array(1 + (1 << level))
	val misses = new Array(THROUGHPUT_FACTOR * #CPU)
	cache[0] = new CacheNode(null, 8, misses)
	return cache

******** Lookup ***********

key: unique identifier
hash: hash code
level: determines which part of the hash to use
cur: the array (ANode) to traverse thru

def lookup(key: KeyType, hash: Int, level: Int, cur: ANode): ValueType =

	// Amount of bits extracted determined by cur length: 2 or 4 bits
	val pos = (hash >>> level) && (cur.length - 1)

	// Check what is in that position in the current position
	val old = READ(cur[pos])

	// If it's empty or marked as to not modify the empty value
	// There is no corresponding key in the cache trie
	if (old == null || old == FVNode)
		return null

	// There is another array (ANode) so jump to the next array (ANode)
	else if (old is an ANode)
		return lookup(key, hash, level + 4, old)

	// Reached a node with the same hash bits so far, check if the keys match	
	else if (old is an SNode)
		if (old.key == key)
			return old.value
		else
			return null

	// If marked for expansion, check what's currently in the temp (narrow) ANode
	else if (old is an ENode)
		val an = old.narrow

		// Linearization point
		return lookup(key, hash, level + 4, an)

	// If frozen, check the ANode contained
	else if (old is an FNode)
		return lookup(key, hash, level, level + 4, old.frozen)

// Initial call to lookup
def lookup(key: KeyType): ValueType =
	lookup(key, hash(key), 0, root)




******** Insert *********

def insert(k: KeyType, v: ValueType, h: Int, lev: Int, cur: ANode, prev: ANode): Boolean =
	
	// Get position in ANode according to size of ANode, level and hash code
	val pos = (h >>> lev) && (cur.length - 1)

	// Check what is at the current position
	val old = READ(cur[pos])

	// If current position is empty
	if (old == null)
		val sn = new SNode(h, k, v, NoTxn)
		// Check nothing has changed, then insert
		if (CAS(cur[pos], old, sn))
			return true
		// Collision, restart at next level
		else
			return insert(k, v, h, lev + 4, old, cur)

	// If there is another array at position, jump to that array
	else if (old is an ANode)
		return insert(k, v, h, lev + 4, old, cur)

	// If we found an entry with the current hash bits
	else if (old is an SNode)

		// Check if it has a special value
		val txn = READ(old.txn)

		// We're allowed to modify the node
		if (txn == NoTxn)

			// If we want to insert a node with the same key
			if (old.key == key)

				val sn = new SNode(h, k, v, NoTxn)

				// Check if nothing has changed and announce that there is new SNode
				if(CAS(old.txn, NoTxn, sn))

					// Insert the actual new SNode
					CAS(cur[pos], old, sn)
					return true

				// Failed to announce there is new SNode so restart
				else
					return insert(k, v, h, lev, cur, prev)

			// Check if ANode is narrow, create ENode to announce expansion
			else if (cur.length == 4)

				// Save the position in the parent
				val ppos = (h >>> (lev - 4)) && (prev.length - 1)

				val en = new ENode(prev, ppos, cur, h, lev)

				// Check that the parent of the current ANode still contains current and then insert the ENode
				if(CAS(prev[ppos], cur, en))

					completeExpansion(en)
					val wide = READ(en.wide)

					// Restart insertion with the wide ANode in the new ENode
					return insert(k, v, h, lev, wide, prev)

				// Failed to insert ENode so restart	
				else
					return insert(k, v, h, lev, cur, prev)

			// If ANode is already wide
			else
				val sn = new SNode(h, k, v, NoTxn)

				// Creates a new ANode with the new and old SNode
				val an = createANode(old, sn, lev + 4)

				// Check if nothing has changed, replace old ANode with new ANode
				if(CAS(old.txn, NoTxn, an))
					CAS(cur[pos], old, an)
					return true
				// Failed so restart
				else
					return insert(k, v, h, lev, cur, prev)

		// Frozen SNode so unable to make changes, returns back up to the ENode in control of this SNode
		else if (txn == FSNode)
			return false

		// If SNode or ANode, help complete concurrent insertion
		else
			// Help update cur[pos] to value at txn
			CAS(cur[pos], old, txn)
			return insert(k, v, h, lev, cur, prev)

	// Help concurrent expansion
	else if (old is an ENode)
		completeExpansion(old)

	// If FVNode or FNode
	return false

// Initial call	
def insert(k: KeyType, v: ValueType) = 
	if(!insert(k, v, hash(k), 0, root, null))
		insert(k, v)

******* Modified Lookup + Fast Lookup (with aux Cache) *******

// "Slow" lookup
def lookup(k: KeyType, hash: Int, lev: Int, cur: ANode, lastCachee: Any, cacheLevel: Int) =
	
	// If a node is at the same level as in the cache
	if (lev == cacheLevel)
		inhabit(cache, cur, hash, lev)
	val pos = position(cur, hash, lev)
	...
	else if(old is an SNode)

		// If not contained at same level as cache or just one deeper
		if (lev is not [cacheLevel or cacheLevel + 4])
			recordCacheMiss()
		if (lev + 4 == cacheLevel)
			inhabit(cache, old, hash, lev + 4)
		if (old.key == key)
	...
			return lookup(key, hash, level + 4, old.frozen)

def fastLookup(k: KeyType): ValueType = 
	val h = hash(k)

	// cacheHead is in scope, appears to be global
	var cache = READ(cacheHead)

	// If there is no cache, start at the root
	if (cache == null)
		return lookup(k, h, 0, root, null, -1)

	// ??? Highest level ?
	val topLevel = countTrailingZeros(cache.length - 1)

	// Starts at the deepest level in cache
	// while we don't encounter a null cache entry
	while (cache != null)
		val pos = 1 + (h && (cache.length - 2))
		val cachee = READ(cache[pos])
		val level = countTrailingZeros(cache.length - 1)

		// Found an entry with the current key bits
		if (cachee is an SNode)
			val txn = READ(old.txn)
			if (txn == NoTxn)
				// Found it
				if (cachee.key == k)
					return cachee.value

				// Couldn't find the node w/ key
				else
					return null

		// Found a level with the current key bits
		else if (cachee is an ANode)

			// Find and read the entry with the current bits
			val cpos = (h >>> level) && (cachee.length - 1)
			val old = READ(cachee[cpos])

			// Continue to next if frozen ANode or frozen empty entry?
			if (old == FVNode || old is an FNode)
				continue

			// Continue to next if we find a frozen entry
			if (old is an SNode)
				if (READ(old.txn) == FSNode)
					continue

			// Go to regular lookup to update cache if necessary
			return lookup(k, h, level, cachee, level)

		// Go up?(maybe down not sure) a level in the cache
		cache = cache[0].parent

	// Could not find in the cache, start at the highest level
	return lookup(k, h, 0, root, null, topLevel)	

****** Freeze n Expand ********

def completeExpansion(en: ENode) = 

	// Prevent further updates to narrow
	freeze(en.narrow)

	var wide = new Array<Any>(16)

	// Copy values of narrow into wide
	copy(en.narrow, wide, en.level)

	// Fail to update wide in ENode, take the wide that is there
	if (!CAS(en.wide, null, wide))
		wide = READ(en.wide)

	// Replace the ENode, in the ANode that contains it, with wide
	CAS(en.parent[en.parentpos], en, wide)

// Traverse thru ANode and freeze its entries
def freeze(cur: ANode) =
	var i = 0
	while (i < cur.length)
		val node = READ(cur[i])

		// If null entry, replace with FVNode
		if (node == null)

			// If fail to replace, reiterate over entry
			if (!CAS(cur[i], node, FVNode)) 
				i -= 1

		// If there is a non null entry
		else if (node is an SNode)
			val txn = READ(node.txn)

			// If no special flag, assign FSNode flag
			if (txn == NoTxn)
				// Fail to flag with FSNode, reiterate over entry
				if (!CAS(node.txn, NoTxn, FSNode))
					i -= 1

			// If assigned any other flag besides none or FSNode
			else if (txn != FSNode)

				// Replace the current entry with whatever is in txn
				// and then reiterate over the entry
				CAS(cur[i], node, txn)
				i -= 1

		// If nested ANode, put in FNode wrapper
		else if (node is an ANode)
			val fn = new FNode(node)

			// Replace current entry with new FNode and reiterate over entry
			CAS(cur[i], node, fn)
			i -= 1

		// If ANode is in an FNode, make sure its entries are frozen too
		else if (node is an FNode)
			freeze(node.frozen)

		// If nested ENode, finish children expansions first then reiterate over entry
		else if (node is an ENode)
			completeExpansion(node)
			i -= 1

		i += 1

******* Inhabit (Populate cache) ********

def inhabit(cache: Array[AnyRef], nv: Any, hash: Int, cacheeLevel: Int) = 
	
	// Create cache only if hash trie has at least a level 12
	if (cache == null)
		if (cacheeLevel >= 12)

			// Intialize cache with one level less than the least amount of levels needed
			cache = createCache(8, null)

			// Update that there is now a cache avaliable
			CAS(cacheHead, null, cache)

			// Recursively call to insert value
			inhabit(cache, nv, hash, cacheeLevel)

	// Cache exists
	else
		val length = cache.length
		val cacheLevel = countTrailingZeros(length - 1)
		if (cacheLevel == cacheeLevel)
			val pos = 1 + (hash && (cache.length - 2))

			// Do not need CAS, just need the most recent value
			// Cache need not be entirely consistent
			WRITE(cache[pos], nv)

******* Cache Misses and Sampling ********

// Neither of these functions are linearlizable 
// "Lack of consistency tolerable, ... worst case, race condition during sampling
// could select an incorrect level, but this is rare, and it gets corrected in the
// next sampling pass."

def recordCacheMiss() = 
	val cache = READ(cacheHead)

	// If a cache exists
	if (cache != null)
		val cn = cache[0]

		// Read the count in the misses array according to thread
		val counterId = THREAD_ID % cn.misses.length
		val count = READ(cn.misses[counterId])

		// Reset counter and adjust the cache level
		if (count > MAX_MISSES)
			WRITE(cn.misses[counterId], 0)
			sampleAndAdjustCache(cache)

		// Increase the miss counter for the current thread
		else
			WRITE(cn.misses[counterId], count + 1)

def sampleAndAdjustCache(cache: Array<Any>) = 
	
	// Pick random hash code and records the num of SNodes at each level
	val histogram = sampleSNodesLevels()

	// Find the most populated (consecuted pair) level of levels
	val best = findMostPopulatedLevel(histogram)

	// Might not be as populated but pretty populate in comparision to most levels
	val prev = countTrailingZeros(cache.length - 1)

	// Adjust if the most populated level is 1.5 more popular than other level
	if (histogram[best] > histogram[prev] * 1.5)
		adjustCacheLevel(best)			