Pseudo Code

-------------- Data Types ------------------

******* Nodes ********

class GenNode
	var node: Object (SNode | ANode | FNode | ENode)
	var nodeType: String

class SNode
	var hash: Int
	var key: Key
	var value: Value
	var txn: GenNode

class ANode
	var array: Array<GenNode>

class FNode
	var frozen: GenNode
	var AorS: String

class ENode
	var parent: GenNode (ANode)
	var parentpos: Int
	var narrow: GenNode (ANode)
	var hash: Int
	var level: Int
	var wide: GenNode (ANode)

******* Hash Trie ********

class HashTrie
	var root: GenNode (ANode)

******* Auxilary Cache ********

class Cache
	var root: Array<GenNode>
	var stats: CacheNode

class CacheNode
	var parent: Cache
	var misses: Int
	var level: Int
	var sample: Array<Int>

******* Cache Trie ********	

class CacheTrie implements HashTrie
	var cacheHead: Cache

-------------- Functions ------------------	

******** HashTrie::Lookup ***********

key: unique identifier
hash: hash code
level: how far away from the root, in multiples of 4 starting at 0 -> 4 * n, n >= 1
curr: the level (ANode) to traverse thru

SNode lookup(key: Key, hash: Int, level: Int, curr: ANode)

	// Find position according to the corresponding bits of the hash for the level
	var pos = (hash >>> level) & (curr.length - 1)

	// Check what is in that position in the current position
	var old = curr[pos]

	// There is no corresponding key in the cache trie
	if (old is null || old is an FNode (null))
		return null

	// There is another level (ANode) so jump to the next level (ANode)
	else if (old is an ANode || old is an FNode (ANode))
		return lookup(key, hash, level + 4, old)

	// Reached a node with the same hash bits so far, check if the keys match	
	else if (old is an SNode || old is an FNode (SNode))
		if (old.key == key)
			return old.value
		else
			return null

	// If marked for expansion, check what's for sure in the level
	else if (old is an ENode)
		var an = old.narrow

		// Linearization point
		return lookup(key, hash, level + 4, an)

	else
		ERROR;


// Initial call to lookup
Object lookup(key: Key)
	lookup(key, hash(key), 0, root)




******** HashTrie::Insert *********

k: unique identifier
h: hash code
lev: how far away from the root, in multiples of 4 starting at 0 -> 4 * n, n >= 1
curr: the current level (ANode) to traverse thru
prev: the previous level (ANode) traversed thru

Boolean insert(k: Key, v: Value, h: Int, lev: Int, curr: ANode, prev: ANode)
	
	// Find position according to the corresponding bits of the hash for the level
	var pos = (h >>> lev) & (curr.length - 1)

	// Check what is at the current position
	var old = curr[pos]

	// There's nothing here, so try to insert
	if (old == null)
		var sn = new SNode(h, k, v, null)
		// Check nothing has changed, then insert
		if (curr.CAS(pos, old, sn))
			return true
		// Collision, restart
		else
			return insert(k, v, h, lev + 4, curr, prev)

	// If there is pointer to another level at the position, jump to next level
	else if (old is an ANode)
		return insert(k, v, h, lev + 4, old, curr)

	// If we found an entry with the current hash bits
	else if (old is an SNode)

		// Check if the current node has yet to update
		var txn = old.txn

		// We're allowed to modify the node
		if (txn is null)

			// If we want to insert a node with the same key
			if (old.key == key)

				var sn = new SNode(h, k, v, null)

				// Check that everything is the same and insert new SNode in txn field of the current SNode for logical insertion
				if(old.txn.CAS(null, sn))

					// Physically update the entry to the new SNode
					curr.CAS(pos, old, sn)
					return true

				// Failed to logically insert new SNode so restart
				else
					return insert(k, v, h, lev, curr, prev)

			// Check if the current level is narrow, create ENode to start expansion
			else if (curr.length == 4)

				// Save the position from the previous level
				var ppos = (h >>> (lev - 4)) & (prev.length - 1)

				var en = new ENode(prev, ppos, curr, h, lev)

				// Check that the previous level still containers the pointer to the current level and then replace it with a pointer to the expansion node
				if(prev.CAS(ppos, curr, en))

					completeExpansion(en)
					var wide = en.wide

					// Restart insertion with the newly expanded level
					return insert(k, v, h, lev, wide, prev)

				// Failed to insert the expansion node to restart	
				else
					return insert(k, v, h, lev, curr, prev)

			// If the current level is already wide, create a new level at the position
			else
				var sn = new SNode(h, k, v, null)

				// Creates a new level with the current SNode entry and new SNode entry
				var an = createANode(old, sn, lev + 4)

				// Check if nothing has changed and insert the newly created level into the txn field of the current SNode for logical insertion
				if(old.txn.CAS(null, an))

					// Physical insertion of the newly created level
					curr.CAS(pos, old, an)

					// Update the txn field back to null to prevent infinite loop due to Java's implicit pointers
					old.txn.CAS(an, null)

					return true

				// Failed to logically insert new level
				else
					return insert(k, v, h, lev, cur, prev)

		// Frozen SNode so unable to make changes, returns back up to the ENode in control of this SNode
		else if (txn is an FNode (SNode))
			return false

		// Help with concurrent physical insertion if logical insertion was successful 
		else
			// Physical insertion from the txn field
			curr.CAS(pos, old, txn)
			return insert(k, v, h, lev, cur, prev)

	// Help concurrent expansion
	else if (old is an ENode)
		completeExpansion(old)

	// If FNode, don't insert because the corresponding slot is "frozen"
	return false

// Initial call	
void insert(k: Key, v: Value) 
	if(!insert(k, v, hash(k), 0, root, null))
		insert(k, v)


****** HashTrie::Freeze & HashTrie/CacheTrie::CompleteExpansion ********

// Traverse thru ANode and freeze its entries
void freeze(cur: ANode)
	var i = 0
	while (i < cur.length)
		var node = cur[i]

		// If null entry, replace with FNode (null)
		if (node is null)

			// If fail to replace, reiterate over entry
			if (!cur.CAS(i, node, FVNode)) 
				i -= 1

		// If there is a non null entry
		else if (node is an SNode)
			var txn = node.txn

			// If entry is not pending for any updates
			if (txn is null)

				var fn = new FNode(node)

				// Fail to insert frozen node into txn for logical insertion, reiterate over entry
				if (!node.txn.CAS(null, fn))
					i -= 1

			// If pending update is anything but a frozen entry
			else if (txn is not an FNode (SNode))

				// Physically insert what's in txn and then reiterate over the entry
				cur.CAS(i, node, txn)
				i -= 1

		// If there is another level, freeze the level and reiterate over it to freeze its' children
		else if (node is an ANode)
			var fn = new FNode(node)

			// Replace current entry with new FNode and reiterate over entry
			cur.CAS(i, node, fn)
			i -= 1

		// Recursively freeze a frozen level's children 
		else if (node is an FNode (SNode))
			freeze(node.frozen)

		// Expand an expansion node first to prevent possible freezing of the same nodes
		else if (node is an ENode)
			completeExpansion(node)
			i -= 1

		else 
			ERROR

		// Continue to the next entry to possibly freeze
		i += 1

// HashTrie version, CacheTrie's completeExpansion calls this as well

boolean completeExpansion(en: ENode) 

	// Prevent further updates to narrow
	freeze(en.narrow)

	var wide = new ANode(16)

	// Copy values of narrow into wide
	copy(en.narrow, wide, en.level)

	// Need to update txn fields of prev frozen SNodes for Java's implicit pointers
	unfreeze(en.narrow)

	// Fail to update wide in ENode, so use the wide that is there
	if (!CAS(en.wide, null, wide))
		wide = en.wide

	// Replace the ENode, in the ANode that contains it, with wide
	return en.parent.CAS(en.parentpos, en, wide)


// CacheTrie version that is dependant on HashTrie's implementation

void completeExpansion(en: ENode, curr: Cache)
	
	if(completeExpansion(en))
		inhabit(curr, en.wide, en.hash, en.level)



******* CacheTrie::FastLookup *******

k: unique identifier
hash: hash code
lev: how far away from the root, in multiples of 4 starting at 0 -> 4 * n, n >= 1
curr: the level (ANode) to traverse thru
currCache: current cache

SNode lookup(k: Key, hash: Int, lev: Int, curr: ANode, currCache: Cache)
	
	// If the cache is non null and cache level is the same as the current level
	if (currCache != null && ((1 << lev) == currCache.length - 1))
		inhabit(cache, curr, hash, lev)

	// Find position according to the corresponding bits of the hash for the level
	var pos = (h >>> lev) & (curr.length - 1)
	
	var old = curr[pos]

	// There is another level so jump to the next level
	if(old is an ANode || FNode (ANode) || ENode)
		return lookup(key, hash, lev + 4, old, currCache)

	else if(old is an SNode || old is an FNode (SNode))

		// If not contained at same level as cache or just one deeper
		if (lev is not in range[cacheLevel, cacheLevel + 4])
			recordCacheMiss()

		// If the cache is non null and next level is the same as the cache level
		if (cache level is equal to current level + 4)
			inhabit(cache, old, hash, lev + 4)

		if (old.node.key == key)
			return old.node
	else
		ERROR

SNode fastLookup(k: Key, h: Int)

	var cache = cacheHead

	// If there is no cache, start at the root
	if (cache == null)
		return lookup(k, h, 0, root, cache)

	var pos = 1 + (h & (cache.size - 2))
	var cachee = cache[pos]

	// If there is nothing in the cache, start at the root
	if (cache == null)
		return lookup(k, h, 0, root, cache)

	// Find SNode in the cache	
	else if (cachee is an SNode)
		var txn = old.txn
		if (txn is null)

			// Found it
			if (cachee.key == k)
				return cachee.value

		// Couldn't find the node w/ key
		else
			return lookup(k, h, 0, root, cache)

	// Found another level
	else if (cachee is an ANode)

		// Find and read the entry with the current bits
		var cpos = (h >>> level) & (cachee.length - 1)
		var old = cachee[pos]

		if (old is an SNode)
			var txn = old.txn
			if (txn is null)
				// Found it
				if (old.key == k)
					return old

			// Couldn't find the node w/ key
			else
				return lookup(k, h, 0, root, cache)

		else if(old is an ENode)
			completeExpansion(old, cache)
			return fastLookup(k, h)

	else
		ERROR

	// Go to regular lookup in any case
	return lookup(k, h, 0, root, cache)

// Initial Call
Object fastLookup(k: Key) 
	fastLookup(k, hash(key))

******* CacheTrie::FastInsert *******

k: unique identifier
v: value
h: hash code
lev: how far away from the root, in multiples of 4 starting at 0 -> 4 * n, n >= 1
curr: the current level (ANode) to traverse thru
prev: the previous level (ANode) traversed thru
cache: current cache

Boolean insert(k: Key, v: Value, h: Int, lev: Int, curr: ANode, prev: ANode, cache: Cache)
	
	// If the cache is non null and cache level is the same as the current level
	if (currCache != null && ((1 << lev) == currCache.length - 1))
		inhabit(cache, curr, hash, lev)

	// Find position according to the corresponding bits of the hash for the level
	var pos = (h >>> lev) & (curr.length - 1)

	// Check what is at the current position
	var old = curr[pos]

	// There's nothing here, so try to insert
	if (old == null)

		// If not contained at same level as cache or just one deeper
		if (lev is not in range[cacheLevel, cacheLevel + 4])
			recordCacheMiss()

		var sn = new SNode(h, k, v, null)
		// Check nothing has changed, then insert
		if (curr.CAS(pos, old, sn))
			return true
		// Collision, restart
		else
			return insert(k, v, h, lev + 4, curr, prev, cache)

	// If there is pointer to another level at the position, jump to next level
	else if (old is an ANode)
		return insert(k, v, h, lev + 4, old, curr, cache)

	// If we found an entry with the current hash bits
	else if (old is an SNode)

		// Check if the current node has yet to update
		var txn = old.txn

		// We're allowed to modify the node
		if (txn is null)

			// If we want to insert a node with the same key
			if (old.key == key)

				var sn = new SNode(h, k, v, null)

				// Check that everything is the same and insert new SNode in txn field of the current SNode for logical insertion
				if(old.txn.CAS(null, sn))

					// Physically update the entry to the new SNode
					curr.CAS(pos, old, sn)
					return true

				// Failed to logically insert new SNode so restart
				else
					return insert(k, v, h, lev, curr, prev, cache)

			// Check if the current level is narrow, create ENode to start expansion
			else if (curr.length == 4)

				// Save the position from the previous level
				var ppos = (h >>> (lev - 4)) & (prev.length - 1)

				var en = new ENode(prev, ppos, curr, h, lev)

				// Check that the previous level still containers the pointer to the current level and then replace it with a pointer to the expansion node
				if(prev.CAS(ppos, curr, en))

					completeExpansion(en, cache)
					var wide = en.wide

					// Restart insertion with the newly expanded level
					return insert(k, v, h, lev, wide, prev, cache)

				// Failed to insert the expansion node to restart	
				else
					return insert(k, v, h, lev, curr, prev, cache)

			// If the current level is already wide, create a new level at the position
			else
				var sn = new SNode(h, k, v, null)

				// Creates a new level with the current SNode entry and new SNode entry
				var an = createANode(old, sn, lev + 4)

				// Check if nothing has changed and insert the newly created level into the txn field of the current SNode for logical insertion
				if(old.txn.CAS(null, an))

					// Physical insertion of the newly created level
					curr.CAS(pos, old, an)

					// Added line to update the txn field back to null

					return true

				// Failed to logically insert new level
				else
					return insert(k, v, h, lev, cur, prev, cache)

		// Frozen SNode so unable to make changes, returns back up to the ENode in control of this SNode
		else if (txn is an FNode (SNode))
			return false

		// Help with concurrent physical insertion if logical insertion was successful 
		else
			// Physical insertion from the txn field
			curr.CAS(pos, old, txn)
			return insert(k, v, h, lev, cur, prev, cache)

	// Help concurrent expansion
	else if (old is an ENode)
		completeExpansion(old, cache)

	// If FNode, don't insert because the corresponding slot is "frozen"
	return false

// Initial call	
void insert(k: Key, v: Value) 
	if(!insert(k, v, hash(k), 0, root, null, cacheHead))
		insert(k, v)


void fastInsert(key: Key, value: Value, hash: Int, curr: Cache, prev: Cache)
	
	// Cache DNE
	if(curr is null)
		insert(key, value)
	// Cache exists
	else
		var pos = 1 + (hash & (curr.length - 1))

		var item = curr[pos]

		var level = curr.length - 1

		// Found nothing so check the parent Cache
		if(item is null)
			// Contains the pointer to the parent Cache and miss statistics
			var stats = curr[0]
			fastInsert(key, value, hash, stats.parent, curr)

		// Another level in current cache
		else if(item is an ANode)
			var aPos = (hash >>> level) & (item.length - 1)
			var old = item[aPos]

			// There is no entry, so attempt to insert
			if(old is null)
				var sn = new SNode(hash, key, value, null)

				// Succesful insertion
				if(item.CAS(aPos, old, sn))
					return

				// Conflict, restart insertion	
				else
					fastInsert(key, value, hash, curr, prev)

			// There is yet another level so we'll hand it off to normal insert
			else if(old is an ANode)
				if(!insert(key, value, hash, level + 4, old, item, prev))
					fastInsert(key, value, hash, curr, prev)

			// Found a corresponding entry at this level
			else if(old is an SNode)
				var txn = item.txn

				// The entry is not pending for any updates
				if(txn is null)
					if(old.key == key)
						var sn = new SNode(hash, key, value, null)

						// Insert into txn field for logical insertion
						if(old.txn.CAS(null, sn))

							// Replace the entry with the new SNode for physical insertion
							item.CAS(aPos, old, sn)

						// Failed to logically insert the new SNode, so restart	
						else
							fastInsert(key, value, hash, curr, prev)

					// Needs to expand before insertion but need parent of item, so restart insertion with parent
					else if(item.length == 4)
						var stats = curr[0]
						fastInsert(key, value, hash, stats.parent, curr)

					// Current level is a wide and no matching key for the entry, create another level at the entry
					else
						var sn = new SNode(hash, key, value, null)
						var newLevel = createANode(old, sn, level + 4)

						// Insert the new level into txn field of current entry for logical insertion
						if(old.txn.CAS(null, newLevel))

							// Physical insertion
							item.CAS(aPos, old, newLevel)

							// Update the txn field back to null to prevent infinite loop due to Java's implicit pointers
							old.txn.CAS(newLevel, null)

						// Failed to logically insert the new level so restart
						else 
							fastInsert(key, value, hash, curr, prev)

				// Some level is still expanding so we do normal insert to help expand since we don't know the "frozen" depth of this node
				else if(txn is an FNode (SNode))
					insert(key, value)

				// Otherwise, help with concurrent physical insertion	
				else
					item.CAS(aPos, old, txn)
					fastInsert(key, value, hash, curr, prev)

			// The entry at the level is either an FNode or ENode, but we don't have a path to the parent node in fastInsert
			else
				insert(key, value)

		// Found an SNode in the base of the current cache but we need the parent to possibly replace this entry
		else if(item is an SNode)
			var stats = curr[0]
			fastInsert(key, value, hash, parent, curr)

		else
			ERROR


******* CacheTrie::Inhabit ********

void inhabit(cache: ANode, nv: ANode, hash: Int, currLevel: Int)
	
	// Create new cache level only if hash trie has a level at or deeper than 12
	if (cache == null)
		if (currLevel >= 12)

			// Intialize cache with one level less than the least amount of levels needed
			// Also create a CacheNode at position 0
			cache = new Cache(8, null)

			// Update the cacheHead with the new cache
			cacheHead.CAS(null, cache)

			// Recursively call to insert hash trie levels into the cache
			inhabit(cache, nv, hash, currLevel)

	// Cache exists
	else
		var length = cache.length
		var cacheLevel = countTrailingZeros(length - 1)
		if (cacheLevel == currLevel)
			var pos = 1 + (hash & (cache.length - 2))

			// Do not need CAS, just need the most recent value since Cache
			// does not be entirely consistent
			cache.set(pos, nv)

******* CacheTrie::RecordCacheMiss ********

// "Lack of consistency tolerable, ... worst case, race condition during sampling
// could select an incorrect level, but this is rare, and it gets corrected in the
// next sampling pass."

void recordCacheMiss() 
	var cache = cacheHead

	// If a cache exists
	if (cache != null)

		var stats = cache[0]

		// Reset counter and adjust the cache level
		if (stats.approximateMissCount() > MAX_MISSES)

			stats.resetMissCount()

			// Sample the levels with a constant number of random hashes that are reachable given the cache head,
			// then updating the stats.sample and adjusting the cacheHead according to the "most" frequently accessed level
			sampleAndAdjustCache(cache, stats)

		// Increase the miss counter for the current cache
		else
			stats.bumpMissCount()
		